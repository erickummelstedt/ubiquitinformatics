# ubiquitinformatics

UBIQUITINFORMATICS - PROJECT KNOWLEDGE SUMMARY
-----------------------------------------------
Date: 2025-05-19

Purpose:
--------
To provide an extensive, human- and GPT-readable summary of the design, logic, and architecture of the Ubiquitinformatics project,
especially the JSON structure, Python simulation, building logic, and supporting functions.

-----------------------------------------------
1️⃣ UBIQUITIN JSON STRUCTURE
-----------------------------------------------

- The ubiquitin chains are represented as deeply nested JSON (or Python dict) structures.
- Each protein has:
    • 'protein' : string → e.g. "1ubq"
    • 'chain_number': int
    • 'FASTA_sequence': str
    • 'chain_length': int
    • 'branching_sites': list of dicts → where each dict represents a lysine (or M1) branch site.

- Example of a branch site dict:
    {
        'site_name': 'K48',
        'sequence_id': 'FAG(K)QLE',
        'children': '' or 'SMAC'/'ABOC' or another dict representing the next ubiquitin
    }

- K63 and K48 are the biologically significant branching points.

- Each JSON (or Python dict) structures has a corresponding context dictionary generated by iterate_through_ubiquitin() function
- Context dictionary:
    {
        "chain_number_list": [1, 2, 3, ...],
        "chain_length_list": [76, 76, ...],
        "multimer_string_name": "",
        "max_chain_number": int,
        "ABOC_lysines": [],
        "SMAC_lysines": [],
        "free_lysines": [],
        "conjugated_lysines": [[parent_chain_number, lysine_site, child_chain_number], ...]
    }

-----------------------------------------------
2️⃣ PYTHON SIMULATION DESIGN
-----------------------------------------------

Core simulation function: ubiquitin_simulation()
- Simulates one reaction step: adding a ubiquitin monomer to an existing chain, or performing a deprotection step.

Reaction types supported:
    'K48' → K48 conjugation
    'K63' → K63 conjugation
    'SMAC_deprot' → remove SMAC
    'ABOC_deprot' → remove ABOC
    'GLOBAL_deprot' → remove all protecting groups
    'FAKE_deprot' → for testing / non-destructive

Subfunctions:
    - inner_wrapper_ubiquitin_simulation()
    - process_ubiquitin_reaction()
    - iterate_through_ubiquitin() → assigns correct chain numbers
    - log_xxx functions

SMAC and ABOC protecting groups are respected — conjugation is blocked if protecting groups present.

-----------------------------------------------
3️⃣ BUILDING FUNCTIONS
-----------------------------------------------

simulate_E2_step():
    - Given a history_dict and list of donor monomers, simulates all K48 and K63 reactions.
    - Returns a list of new history_dicts.
    - Has a skip logic → prevents SMAC-K48 reacting with K63 and vice versa.

simulate_deprot_step():
    - Simulates SMAC_deprot and Fake_Wash reactions.

assign_correct_E2_enzyme():
    - Determines enzyme used:
        'gp78/Ube2g2' → K48 elongation from K48
        'Ube2K' → K48 elongation from K63 or K48 branching
        'Ubc13/Mms2' → any K63 reaction

validate_conjugated_lysines():
    - Ensures all conjugated lysines are either K48 or K63.

determine_elongation_or_branching():
    - Checks whether new conjugation is elongation or branching.

determine_reaction_type():
    - Returns 'K48_reaction' or 'K63_reaction'.

assign_enzyme():
    - Maps reaction type + elongation/branching to enzyme name.

determine_Ube2K_elongation():
    - Specifically checks for Ube2K vs Ube2G2.

-----------------------------------------------
4️⃣ DESIGN LEARNINGS & RULES
-----------------------------------------------

- The conjugated_lysines list must be of form:
    [[parent_chain_number, lysine_site, child_chain_number]]

- Context validation is strict:
    • Only K48 or K63 are supported for now.
    • Lists must be lists of length 3, otherwise TypeError raised.

- Reaction skip logic in simulate_E2_step:
    • Prevents monomers reacting with themselves if their protected branch site does not match reaction type.

- Branching vs elongation:
    • Determined by how many times a chain number appears in product_conjugated_lysines.

- Ubiquitin chain growth must always be one chain number longer than before.
    • product max_chain_number must == reactant max_chain_number + 1.

-----------------------------------------------
5️⃣ TESTING STRATEGY
-----------------------------------------------

- Full parametrized tests for:
    • assign_enzyme
    • determine_reaction_type
    • determine_elongation_or_branching
    • determine_Ube2K_elongation
    • validate_conjugated_lysines
    • assign_correct_E2_enzyme
    • simulate_E2_step (including skip logic)
    • simulate_deprot_step

- Integration test: simulate_E2_step → simulate_deprot_step → assign_correct_E2_enzyme.

-----------------------------------------------
6️⃣ KEY PROJECT PHILOSOPHY
-----------------------------------------------

- The JSON structure reflects *physical reality* → nesting = ubiquitins bound together in a tree-like structure.

- Numbering system reflects a pre-order treversal.

- Context reflects *simulation state* → validates what has happened.

- Protecting groups enable simulation of chemically realistic synthesis routes.

- Reactions are strictly validated to match biological & chemical rules.



# License

This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.


# Requirements

```Bash
pyenv local 3.11.3
python -m venv .venv
source .venv/bin/activate
pip install --upgrade pip
pip install -r requirements_pip.txt

```

```Conda 
conda create -n myenv python
conda activate myenv
conda config --append channels conda-forge
conda install --file requirements_conda.txt


``` NOTES
openbabel is easily install in conda
opentrons is easily installed in pip/venv